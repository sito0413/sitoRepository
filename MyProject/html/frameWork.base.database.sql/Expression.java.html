<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Expression.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">カバレッジ</a> &gt; <a href="index.source.html" class="el_package">frameWork.base.database.sql</a> &gt; <span class="el_source">Expression.java</span></div><h1>Expression.java</h1><pre class="source lang-java linenums">package frameWork.base.database.sql;

public class Expression {
	private final String expression;
	
<span class="nc" id="L6">	public Expression(final String expression) {</span>
<span class="nc" id="L7">		this.expression = expression;</span>
<span class="nc" id="L8">	}</span>
	
	@Override
	public String toString() {
<span class="nc" id="L12">		return expression.toString();</span>
	}
	// TODO 自動生成されたコンストラクター・スタブ
	//		[AS] 文字列
	//		評価式
	//
	//		評価式 ::=	評価式 二項演算子 評価式 |
	//		評価式 LIKE演算子 評価式 |
	//		単項演算子 評価式 |
	//		( 評価式 ) |
	//		カラム名 |
	//		テーブル名 . カラム名 |
	//		データベース名 . テーブル名 . カラム名 |
	//		定数値 |
	//		関数名 ( 評価式の並び | * ) |
	//		評価式 (+) |
	//		評価式 ISNULL |
	//		評価式 NOTNULL |
	//		評価式 [NOT] BETWEEN 評価式 AND 評価式 |
	//		評価式 [NOT] IN ( 値の並び ) |
	//		評価式 [NOT] IN ( SELECT文 ) |
	//		( SELECT文 ) |
	//		CASE [評価式] ( WHEN 評価式 THEN 評価式 )+ [ELSE 評価式] END
	//		LIKE演算子 ::=	LIKE | GLOB | NOT LIKE | NOT GLOB
	//		このセクションはほかのものとは異なります。このドキュメントの中で、 ほかのほとんどのセクションでは特定の SQL コマンドについて解説しています。 このセクションでは単独のコマンドについて述べるのではなく、 ほかのほとんどのコマンドの一部となる『評価式』について説明します。
	//
	//		SQLite は以下の二項演算子を理解します。 上にあるものほど優先順位が高くなっています：
	//
	//		||
	//		*    /    %
	//		+    -
	//		&lt;&lt;   &gt;&gt;   &amp;    |
	//		&lt;    &lt;=   &gt;    &gt;=
	//		=    ==   !=   &lt;&gt;   IN
	//		AND
	//		OR
	//		サポートしている単項演算子は以下の通りです：
	//
	//		-    +    !    ~
	//		SQLite のどんな値でも評価式の一部にすることができます。 算術演算においては整数は整数として扱われます。 文字列はまず atof() で実数に変換されます。 比較演算子においては、数値は数値として比較し、 文字列の比較では strcmp() 関数が使われます。 等号と不等号にはそれぞれ 2 つのバリエーションがあるので注意してください。 等号は= または == です。 不等号は!= または &lt;&gt; です。 || 演算子は『文字列の連結』です - オペランドである 2 つの文字列を結合します。 % 演算子は左辺を右辺で割った余りを出力します。
	//
	//		LIKE 演算子はワイルドカードによる比較を行います。 右辺のオペランドにはワールドカードを含みます。 右辺の中のパーセント文字 % は、 左辺にある 0 個以上の任意の文字の並びにマッチします。 右辺の中のアンダースコア _ は、 左辺にある 1 個の任意の文字にマッチします。 LIKE 演算子は大文字小文字を区別しないので、 片方にある大文字と反対側の小文字がマッチしてしまいます。 （バグ：SQLite は 7 bit LATIN 文字の場合のみ大文字小文字を理解します。 たとえば 'a' LIKE 'A' という式は真になりますが 'æ' LIKE 'Æ' は偽になります。） 中置の LIKE 演算子は like(X,Y) ユーザ関数とは別物です。
	//
	//		GLOB 演算子は LILE に似ていますが、 こちらはワイルドカードに UNIX ファイルのグロビングの書式を使います。 また GLOB は LIKE とは異なり大文字小文字を区別します。 GLOB も LIKE も頭に NOT をつければ条件の意味が反対になります。 中置の GLOB 演算子はユーザ関数 glob(X,Y) とは別物です。
	//
	//		カラム名には CREATE TABLE ステートメントで定義された名前のいずれか、 または特殊な識別子である &quot;ROWID&quot;, &quot;OID&quot;, &quot;_ROWID_&quot; のいずれかを指定します。これらの特殊な識別子は、どれも各テーブルの各行に 関連付けられたユニークでランダムなキー（&quot;行キー&quot;）を表します。 CREATE TABLE ステートメントで同じ名前を持つ実際のカラムを定義しない場合、 これらの特殊な識別子は行キーだけを参照します。 行キーはリードオンリーのカラムのように振舞います。 行キーは通常のカラムを書けるところであればどこででも使えます。 ただし行キーの値を UPDATE や INSERT ステートメントで変更することはできません。 &quot;SELECT * ...&quot; では行キーの値は返しません。
	//
	//		SQLite は Oracle8 の外部結合動作を最小限サポートしています。 &quot;カラム名&quot; もしくは &quot;テーブル名.カラム名&quot; という評価式の後に特別の &quot;(+)&quot; 演算子を付けることができます。 カラム評価式のテーブルが結合において２番目もしくは後続のテーブルである場合、 そのテーブルは LEFT OUTER JOIN の左辺のテーブルになります。 このテーブルを使う評価式は、この結合に関する ON 句の一部となります。 Oracle8 の振る舞いが忠実に実装されているわけではありませんが、 SQLite と Oracle 双方で正しく動作するクエリーを構築することはできます。
	//
	//		評価式の中の IN 演算子の右辺オペランドもしくはスカラー値の並びのところに SELECT ステートメントを書くことができます。いずれの場合においても、その SELECT では結果セットにひとつのカラムだけを持つようにしなければなりません。 ここには（ UNION または EXCEPT のようなキーワードで結合された）SELECT の 合成物を書いても構いません。評価式の中の SELECT はほかのすべての処理が 行われる前に一度だけ評価されますので、SELECT 自身の中に書かれた評価式は どれも入っている評価式の中のデータを参照しません。
	//
	//		SELECT が IN 演算子の右辺オペランドの場合、左辺の評価結果が SELECT が 生成した値のいずれかであれば真が返されます。IN 演算子の前に NOT が 置かれると、そのテストの意味が反対になります。
	//
	//		SELECT が IN 演算子の左辺以外の評価式中に現れると、その SELECT の結果の 最初の行が評価式で使われる値になります。SELECT が複数の行を返した場合、 先頭行以外はすべて無視されます。SELECT が全く行を返さない場合、その SELECT の値は NULL になります。
	//
	//		関数については単純なもの、および集約されたもののいずれもサポートされて います。単純な関数はどの評価式の中でも使えます。単純な関数は、その入力 に応じて即座に値を返します。集約関数は SELECT ステートメントの中だけで 使われます。集約関数は結果セットの行すべてについて、それらの結果を計算 します。
	//
	//		以下の関数はデフォルトで有効になっています。また追加の関数を C で書き、 sqlite_creat e_function() API を使ってデータベースエンジンに追加することもできます。
	//
	//		abs(X)	引数 X の絶対値を返します。
	//		coalesce(X,Y,...)	引数のうち NULL でない最初のもののコピーを返します。 引数のいずれも NULL の場合は NULL が返されます。 少なくとも２個の引数が必要です。
	//		glob(X,Y)	この関数は SQLite の &quot;Y GLOB X&quot; という書式を 実装するのに使われます。 sqlite_create_function() インターフェースを使えばこの関数をオーバーライドできるので、 GLOB 演算子の振る舞いを変えることができます。
	//		ifnull(X,Y)	引数のうち NULL でない最初のもののコピーを返します。 引数のいずれも NULL の場合は NULL が返されます。前述の coalesce() と同じ振る舞いをします。
	//		last_insert_rowid()	このデータベースへの今回の接続において最後に INSERT された行の ROWID を返します。これが返す値は sqlite_last_insert_rowid() API 関数から返されるものと同じです。
	//		length(X)	X の文字列長を文字数で返します。SQLite が UTF-8 サポート付きで構築されていれば、バイト数ではなく UTF-8 での文字数が返ります。
	//		like(X,Y)	この関数は SQL の &quot;Y LIKE X&quot; という書式を実装します。 sqlite_create_function() インターフェースはこの関数をオーバーライドし、 LIKE 演算子の振る舞いを変更します。
	//		lower(X)	文字列 X をすべて小文字に変換し、そのコピーを返します。 変換処理には C ライブラリの tolower() ルーチンが使われます。つまり、 この関数は UTF-8 文字列に対してはうまく働かないでしょう。
	//		max(X,Y,...)	引数のうち最大のものを返します。引数には数値だけでなく 文字列も指定できます。最大値は通常のソート順により決められます。注意： max() は２つ以上の引数を取る場合は単純な関数ですが、引数がひとつだけ の場合は集約関数に変換されます。
	//		min(X,Y,...)	引数のうち最小のものを返します。引数には数値だけでなく 文字列も指定できます。最小値は通常のソート順により決められます。注意： min() は２つ以上の引数を取る場合は単純な関数ですが、引数がひとつだけ の場合は集約関数に変換されます。
	//		nullif(X,Y)	引数が異なる場合は最初の引数を返し、そうでなければ NULL を返します。
	//		random(*)	-2147483648 と +2147483647 の間で整数の乱数を返します。
	//		round(X)
	//		round(X,Y)	数値 X を少数以下 Y 桁で四捨五入します。 引数 Y を省略すると 0 と見なされます。
	//		soundex(X)	文字列 X の soundex エンコーディング計算します。 引数が NULL の場合は文字列 &quot;?000&quot; が返されます。SQLite では、この関数は デフォルトでは組み込まれません。SQLite のビルドの際に -DSQLITE_SOUNDEX=1 コンパイルオプションを指定した場合のみ使用できます。
	//		sqlite_version(*)	動作中の SQLite ライブラリのバージョン文字列を返します。 例：&quot;2.8.0&quot;
	//		substr(X,Y,Z)	入力文字列 X の Y 桁目から始まる Z 文字分の部分文字列を返します。X の最小文字数は 1 です。 Y が負の数の場合、部分文字列の最初の文字は 左側からではなく右側から数えられます。SQLite が UTF-8 サポート付きで 構築されている場合、文字のインデックスはバイト単位ではなく実際の UTF-8 文字を指します。
	//		typeof(X)	評価式 X の型を返します。返される値は &quot;numeric&quot; か &quot;text&quot; のいずれかしかありません。SQLite のデータ型の扱いについては Datatypes in SQLite（訳注：まだ英語のまま）に解説があります。
	//		upper(X)	文字列 X をすべて大文字に変換します。 変換処理には C ライブラリの toupper() ルーチンが使われます。つまり、 この関数は UTF-8 文字列に対してはうまく働かないでしょう。
	//		以下の集約関数はデフォルトで使用可能になっています。C で書かれた追加の 集約関数が sqlite_create_aggregate() final API を使って追加可能です。
	//
	//		avg(X)	グループの中ですべての final X の値の平均を返します。
	//		count(X)
	//		count(*)	最初の書式は、そのグループの中において NULL でない X の数を返します。 ２番目の書式（引数なし）は、そのグループにおける行の総数を返します。
	//		max(X)	そのグループにおけるすべての値のうち最大のものを返します。 最大値は通常のソート順で決められます。
	//		min(X)	そのグループにおけるすべての値のうち最小のものを返します。 最小値は通常のソート順で決められます。
	//		sum(X)	そのグループにおけるすべての値の合計を返します。
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>